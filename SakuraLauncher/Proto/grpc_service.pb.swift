// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: grpc_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// User represents the current user metadata and login status.
struct User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: User.Status = .unknown

  var id: Int32 = 0

  var name: String = String()

  var avatar: String = String()

  var speed: String = String()

  var tunnels: Int32 = 0

  var realname: Int32 = 0

  var group: User.Group {
    get {return _group ?? User.Group()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  /// [Today, Total]
  var traffic: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The status is not determined yet, used on initialization.
    case unknown // = 0
    case noLogin // = 1

    /// Logging in.
    case pending // = 2
    case loggedIn // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .noLogin
      case 2: self = .pending
      case 3: self = .loggedIn
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .noLogin: return 1
      case .pending: return 2
      case .loggedIn: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct Group {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var level: Int32 = 0

    var expires: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _group: User.Group? = nil
}

#if swift(>=4.2)

extension User.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [User.Status] = [
    .unknown,
    .noLogin,
    .pending,
    .loggedIn,
  ]
}

#endif  // swift(>=4.2)

struct StatsEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalUl: Int64 = 0

  var totalDl: Int64 = 0

  var connections: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StatsUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tunnels: Dictionary<Int32,StatsEntry> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Log {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var category: Log.Category = .unknown

  var level: Log.Level = .debug

  var time: Int64 = 0

  var source: String = String()

  var data: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Category: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Used to broadcast a dummy log entry, should be ignored.
    case unknown // = 0
    case alert // = 1
    case frpc // = 2
    case service // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .alert
      case 2: self = .frpc
      case 3: self = .service
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .alert: return 1
      case .frpc: return 2
      case .service: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum Level: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case debug // = 0
    case info // = 1
    case warn // = 2
    case error // = 3
    case fatal // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .debug
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .debug
      case 1: self = .info
      case 2: self = .warn
      case 3: self = .error
      case 4: self = .fatal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .debug: return 0
      case .info: return 1
      case .warn: return 2
      case .error: return 3
      case .fatal: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Log.Category: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Log.Category] = [
    .unknown,
    .alert,
    .frpc,
    .service,
  ]
}

extension Log.Level: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Log.Level] = [
    .debug,
    .info,
    .warn,
    .error,
    .fatal,
  ]
}

#endif  // swift(>=4.2)

struct LogList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [Log] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ServiceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bypassProxy: Bool = false

  var updateInterval: Int32 = 0

  var remoteManagement: Bool = false

  /// The value will be "SET" for S->C, and new key for C->S
  var remoteManagementKey: String = String()

  var frpcForceTls: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SoftwareUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceVersion: String = String()

  var frpcVersion: String = String()

  var status: SoftwareUpdate.Status = .noUpdate

  var downloadTotal: UInt32 = 0

  var downloadCompleted: UInt32 = 0

  var releaseNote: String = String()

  var updateURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case noUpdate // = 0
    case downloading // = 1
    case ready // = 2
    case failed // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .noUpdate
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noUpdate
      case 1: self = .downloading
      case 2: self = .ready
      case 3: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .noUpdate: return 0
      case .downloading: return 1
      case .ready: return 2
      case .failed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension SoftwareUpdate.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [SoftwareUpdate.Status] = [
    .noUpdate,
    .downloading,
    .ready,
    .failed,
  ]
}

#endif  // swift(>=4.2)

struct Tunnel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var node: Int32 = 0

  var name: String = String()

  var type: String = String()

  var note: String = String()

  var extra: String = String()

  var localIp: String = String()

  var localPort: Int32 = 0

  var remote: String = String()

  /// 0 = Normal, 1 = Disabled, 2 = Banned
  var status: Int32 = 0

  var enabled: Bool = false

  var state: Tunnel.State = .idle

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum State: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Not started yet
    case idle // = 0

    /// Start command executed, waiting for first report [Report -> RUNNING,
    /// Exited -> CRASHED]
    case started // = 1

    /// Normal running [Exited -> CRASHED]
    case running // = 2

    /// Stop requested, waiting for exit [Exited -> IDLE]
    case stopping // = 3

    /// Process exited, pending resource cleanup [Enabled -> STARTING, otherwise
    /// -> IDLE]
    case crashed // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .idle
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .idle
      case 1: self = .started
      case 2: self = .running
      case 3: self = .stopping
      case 4: self = .crashed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .idle: return 0
      case .started: return 1
      case .running: return 2
      case .stopping: return 3
      case .crashed: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Tunnel.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Tunnel.State] = [
    .idle,
    .started,
    .running,
    .stopping,
    .crashed,
  ]
}

#endif  // swift(>=4.2)

struct TunnelUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: TunnelUpdate.Action = .unknown

  var tunnel: Tunnel {
    get {return _tunnel ?? Tunnel()}
    set {_tunnel = newValue}
  }
  /// Returns true if `tunnel` has been explicitly set.
  var hasTunnel: Bool {return self._tunnel != nil}
  /// Clears the value of `tunnel`. Subsequent reads from it will return its default value.
  mutating func clearTunnel() {self._tunnel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Action: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Used to broadcast a dummy update, should be ignored.
    case unknown // = 0
    case add // = 1
    case update // = 2
    case delete // = 3
    case clear // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .add
      case 2: self = .update
      case 3: self = .delete
      case 4: self = .clear
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .add: return 1
      case .update: return 2
      case .delete: return 3
      case .clear: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _tunnel: Tunnel? = nil
}

#if swift(>=4.2)

extension TunnelUpdate.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [TunnelUpdate.Action] = [
    .unknown,
    .add,
    .update,
    .delete,
    .clear,
  ]
}

#endif  // swift(>=4.2)

struct Node {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var name: String = String()

  var flag: Int32 = 0

  var host: String = String()

  var description_p: String = String()

  var vip: Int32 = 0

  var band: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct NodeList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodes: Dictionary<Int32,Node> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StateUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var user: User {
    get {return _storage._user ?? User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var nodes: NodeList {
    get {return _storage._nodes ?? NodeList()}
    set {_uniqueStorage()._nodes = newValue}
  }
  /// Returns true if `nodes` has been explicitly set.
  var hasNodes: Bool {return _storage._nodes != nil}
  /// Clears the value of `nodes`. Subsequent reads from it will return its default value.
  mutating func clearNodes() {_uniqueStorage()._nodes = nil}

  var config: ServiceConfig {
    get {return _storage._config ?? ServiceConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {_uniqueStorage()._config = nil}

  var update: SoftwareUpdate {
    get {return _storage._update ?? SoftwareUpdate()}
    set {_uniqueStorage()._update = newValue}
  }
  /// Returns true if `update` has been explicitly set.
  var hasUpdate: Bool {return _storage._update != nil}
  /// Clears the value of `update`. Subsequent reads from it will return its default value.
  mutating func clearUpdate() {_uniqueStorage()._update = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Empty: @unchecked Sendable {}
extension LoginRequest: @unchecked Sendable {}
extension User: @unchecked Sendable {}
extension User.Status: @unchecked Sendable {}
extension User.Group: @unchecked Sendable {}
extension StatsEntry: @unchecked Sendable {}
extension StatsUpdate: @unchecked Sendable {}
extension Log: @unchecked Sendable {}
extension Log.Category: @unchecked Sendable {}
extension Log.Level: @unchecked Sendable {}
extension LogList: @unchecked Sendable {}
extension ServiceConfig: @unchecked Sendable {}
extension SoftwareUpdate: @unchecked Sendable {}
extension SoftwareUpdate.Status: @unchecked Sendable {}
extension Tunnel: @unchecked Sendable {}
extension Tunnel.State: @unchecked Sendable {}
extension TunnelUpdate: @unchecked Sendable {}
extension TunnelUpdate.Action: @unchecked Sendable {}
extension Node: @unchecked Sendable {}
extension NodeList: @unchecked Sendable {}
extension StateUpdate: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Empty, rhs: Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginRequest, rhs: LoginRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
    4: .same(proto: "avatar"),
    5: .same(proto: "speed"),
    6: .same(proto: "tunnels"),
    7: .same(proto: "realname"),
    8: .same(proto: "group"),
    9: .same(proto: "traffic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.speed) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.tunnels) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.realname) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 9: try { try decoder.decodeRepeatedInt64Field(value: &self.traffic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 4)
    }
    if !self.speed.isEmpty {
      try visitor.visitSingularStringField(value: self.speed, fieldNumber: 5)
    }
    if self.tunnels != 0 {
      try visitor.visitSingularInt32Field(value: self.tunnels, fieldNumber: 6)
    }
    if self.realname != 0 {
      try visitor.visitSingularInt32Field(value: self.realname, fieldNumber: 7)
    }
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.traffic.isEmpty {
      try visitor.visitPackedInt64Field(value: self.traffic, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: User, rhs: User) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.tunnels != rhs.tunnels {return false}
    if lhs.realname != rhs.realname {return false}
    if lhs._group != rhs._group {return false}
    if lhs.traffic != rhs.traffic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension User.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "NoLogin"),
    2: .same(proto: "Pending"),
    3: .same(proto: "LoggedIn"),
  ]
}

extension User.Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = User.protoMessageName + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "level"),
    3: .same(proto: "expires"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.expires) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 2)
    }
    if self.expires != 0 {
      try visitor.visitSingularInt64Field(value: self.expires, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: User.Group, rhs: User.Group) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.level != rhs.level {return false}
    if lhs.expires != rhs.expires {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StatsEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StatsEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_ul"),
    2: .standard(proto: "total_dl"),
    3: .same(proto: "connections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.totalUl) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalDl) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.connections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalUl != 0 {
      try visitor.visitSingularInt64Field(value: self.totalUl, fieldNumber: 1)
    }
    if self.totalDl != 0 {
      try visitor.visitSingularInt64Field(value: self.totalDl, fieldNumber: 2)
    }
    if self.connections != 0 {
      try visitor.visitSingularInt32Field(value: self.connections, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StatsEntry, rhs: StatsEntry) -> Bool {
    if lhs.totalUl != rhs.totalUl {return false}
    if lhs.totalDl != rhs.totalDl {return false}
    if lhs.connections != rhs.connections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StatsUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StatsUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tunnels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,StatsEntry>.self, value: &self.tunnels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tunnels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,StatsEntry>.self, value: self.tunnels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StatsUpdate, rhs: StatsUpdate) -> Bool {
    if lhs.tunnels != rhs.tunnels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Log"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "level"),
    3: .same(proto: "time"),
    4: .same(proto: "source"),
    5: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.time) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.category != .unknown {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 1)
    }
    if self.level != .debug {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 2)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 3)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Log, rhs: Log) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.level != rhs.level {return false}
    if lhs.time != rhs.time {return false}
    if lhs.source != rhs.source {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Log.Category: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "Alert"),
    2: .same(proto: "Frpc"),
    3: .same(proto: "Service"),
  ]
}

extension Log.Level: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Debug"),
    1: .same(proto: "Info"),
    2: .same(proto: "Warn"),
    3: .same(proto: "Error"),
    4: .same(proto: "Fatal"),
  ]
}

extension LogList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LogList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LogList, rhs: LogList) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServiceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServiceConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bypass_proxy"),
    2: .standard(proto: "update_interval"),
    3: .standard(proto: "remote_management"),
    4: .standard(proto: "remote_management_key"),
    5: .standard(proto: "frpc_force_tls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.bypassProxy) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.updateInterval) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.remoteManagement) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.remoteManagementKey) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.frpcForceTls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bypassProxy != false {
      try visitor.visitSingularBoolField(value: self.bypassProxy, fieldNumber: 1)
    }
    if self.updateInterval != 0 {
      try visitor.visitSingularInt32Field(value: self.updateInterval, fieldNumber: 2)
    }
    if self.remoteManagement != false {
      try visitor.visitSingularBoolField(value: self.remoteManagement, fieldNumber: 3)
    }
    if !self.remoteManagementKey.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteManagementKey, fieldNumber: 4)
    }
    if self.frpcForceTls != false {
      try visitor.visitSingularBoolField(value: self.frpcForceTls, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ServiceConfig, rhs: ServiceConfig) -> Bool {
    if lhs.bypassProxy != rhs.bypassProxy {return false}
    if lhs.updateInterval != rhs.updateInterval {return false}
    if lhs.remoteManagement != rhs.remoteManagement {return false}
    if lhs.remoteManagementKey != rhs.remoteManagementKey {return false}
    if lhs.frpcForceTls != rhs.frpcForceTls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SoftwareUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SoftwareUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_version"),
    2: .standard(proto: "frpc_version"),
    3: .same(proto: "status"),
    4: .standard(proto: "download_total"),
    5: .standard(proto: "download_completed"),
    6: .standard(proto: "release_note"),
    7: .standard(proto: "update_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.frpcVersion) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.downloadTotal) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.downloadCompleted) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.releaseNote) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.updateURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceVersion, fieldNumber: 1)
    }
    if !self.frpcVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.frpcVersion, fieldNumber: 2)
    }
    if self.status != .noUpdate {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if self.downloadTotal != 0 {
      try visitor.visitSingularUInt32Field(value: self.downloadTotal, fieldNumber: 4)
    }
    if self.downloadCompleted != 0 {
      try visitor.visitSingularUInt32Field(value: self.downloadCompleted, fieldNumber: 5)
    }
    if !self.releaseNote.isEmpty {
      try visitor.visitSingularStringField(value: self.releaseNote, fieldNumber: 6)
    }
    if !self.updateURL.isEmpty {
      try visitor.visitSingularStringField(value: self.updateURL, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SoftwareUpdate, rhs: SoftwareUpdate) -> Bool {
    if lhs.serviceVersion != rhs.serviceVersion {return false}
    if lhs.frpcVersion != rhs.frpcVersion {return false}
    if lhs.status != rhs.status {return false}
    if lhs.downloadTotal != rhs.downloadTotal {return false}
    if lhs.downloadCompleted != rhs.downloadCompleted {return false}
    if lhs.releaseNote != rhs.releaseNote {return false}
    if lhs.updateURL != rhs.updateURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SoftwareUpdate.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NoUpdate"),
    1: .same(proto: "Downloading"),
    2: .same(proto: "Ready"),
    3: .same(proto: "Failed"),
  ]
}

extension Tunnel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Tunnel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "node"),
    3: .same(proto: "name"),
    4: .same(proto: "type"),
    5: .same(proto: "note"),
    6: .same(proto: "extra"),
    10: .standard(proto: "local_ip"),
    11: .standard(proto: "local_port"),
    12: .same(proto: "remote"),
    7: .same(proto: "status"),
    8: .same(proto: "enabled"),
    9: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.node) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.note) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.extra) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.localIp) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.localPort) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.remote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.node != 0 {
      try visitor.visitSingularInt32Field(value: self.node, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 4)
    }
    if !self.note.isEmpty {
      try visitor.visitSingularStringField(value: self.note, fieldNumber: 5)
    }
    if !self.extra.isEmpty {
      try visitor.visitSingularStringField(value: self.extra, fieldNumber: 6)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 7)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 8)
    }
    if self.state != .idle {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 9)
    }
    if !self.localIp.isEmpty {
      try visitor.visitSingularStringField(value: self.localIp, fieldNumber: 10)
    }
    if self.localPort != 0 {
      try visitor.visitSingularInt32Field(value: self.localPort, fieldNumber: 11)
    }
    if !self.remote.isEmpty {
      try visitor.visitSingularStringField(value: self.remote, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tunnel, rhs: Tunnel) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.node != rhs.node {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.note != rhs.note {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.localIp != rhs.localIp {return false}
    if lhs.localPort != rhs.localPort {return false}
    if lhs.remote != rhs.remote {return false}
    if lhs.status != rhs.status {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tunnel.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IDLE"),
    1: .same(proto: "STARTED"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "STOPPING"),
    4: .same(proto: "CRASHED"),
  ]
}

extension TunnelUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TunnelUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "tunnel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tunnel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    try { if let v = self._tunnel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TunnelUpdate, rhs: TunnelUpdate) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs._tunnel != rhs._tunnel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TunnelUpdate.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "Add"),
    2: .same(proto: "Update"),
    3: .same(proto: "Delete"),
    4: .same(proto: "Clear"),
  ]
}

extension Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Node"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "flag"),
    4: .same(proto: "host"),
    5: .same(proto: "description"),
    6: .same(proto: "vip"),
    7: .same(proto: "band"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.flag) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.vip) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.band) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.flag != 0 {
      try visitor.visitSingularInt32Field(value: self.flag, fieldNumber: 3)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if self.vip != 0 {
      try visitor.visitSingularInt32Field(value: self.vip, fieldNumber: 6)
    }
    if !self.band.isEmpty {
      try visitor.visitSingularStringField(value: self.band, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Node, rhs: Node) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.flag != rhs.flag {return false}
    if lhs.host != rhs.host {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.vip != rhs.vip {return false}
    if lhs.band != rhs.band {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NodeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NodeList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Node>.self, value: &self.nodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Node>.self, value: self.nodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NodeList, rhs: NodeList) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StateUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StateUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "nodes"),
    3: .same(proto: "config"),
    4: .same(proto: "update"),
  ]

  fileprivate class _StorageClass {
    var _user: User? = nil
    var _nodes: NodeList? = nil
    var _config: ServiceConfig? = nil
    var _update: SoftwareUpdate? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _nodes = source._nodes
      _config = source._config
      _update = source._update
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._nodes) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._update) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._nodes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._update {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StateUpdate, rhs: StateUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._nodes != rhs_storage._nodes {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._update != rhs_storage._update {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
