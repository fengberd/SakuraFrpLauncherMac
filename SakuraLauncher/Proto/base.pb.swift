// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: base.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum MessageID: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case userLogin // = 0
  case userLogout // = 1
  case userInfo // = 2
  case tunnelList // = 3
  case tunnelReload // = 4
  case tunnelUpdate // = 5
  case tunnelDelete // = 8
  case tunnelCreate // = 9
  case logGet // = 6
  case logClear // = 7
  case nodeList // = 10
  case nodeReload // = 11
  case controlExit // = 12
  case controlConfigGet // = 13
  case controlConfigSet // = 14
  case controlCheckUpdate // = 15
  case controlGetUpdate // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .userLogin
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .userLogin
    case 1: self = .userLogout
    case 2: self = .userInfo
    case 3: self = .tunnelList
    case 4: self = .tunnelReload
    case 5: self = .tunnelUpdate
    case 6: self = .logGet
    case 7: self = .logClear
    case 8: self = .tunnelDelete
    case 9: self = .tunnelCreate
    case 10: self = .nodeList
    case 11: self = .nodeReload
    case 12: self = .controlExit
    case 13: self = .controlConfigGet
    case 14: self = .controlConfigSet
    case 15: self = .controlCheckUpdate
    case 16: self = .controlGetUpdate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .userLogin: return 0
    case .userLogout: return 1
    case .userInfo: return 2
    case .tunnelList: return 3
    case .tunnelReload: return 4
    case .tunnelUpdate: return 5
    case .logGet: return 6
    case .logClear: return 7
    case .tunnelDelete: return 8
    case .tunnelCreate: return 9
    case .nodeList: return 10
    case .nodeReload: return 11
    case .controlExit: return 12
    case .controlConfigGet: return 13
    case .controlConfigSet: return 14
    case .controlCheckUpdate: return 15
    case .controlGetUpdate: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MessageID: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [MessageID] = [
    .userLogin,
    .userLogout,
    .userInfo,
    .tunnelList,
    .tunnelReload,
    .tunnelUpdate,
    .tunnelDelete,
    .tunnelCreate,
    .logGet,
    .logClear,
    .nodeList,
    .nodeReload,
    .controlExit,
    .controlConfigGet,
    .controlConfigSet,
    .controlCheckUpdate,
    .controlGetUpdate,
  ]
}

#endif  // swift(>=4.2)

enum PushMessageID: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case updateUser // = 0
  case updateTunnel // = 1
  case updateTunnels // = 2
  case updateNodes // = 3
  case appendLog // = 4
  case pushUpdate // = 5
  case pushConfig // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .updateUser
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .updateUser
    case 1: self = .updateTunnel
    case 2: self = .updateTunnels
    case 3: self = .updateNodes
    case 4: self = .appendLog
    case 5: self = .pushUpdate
    case 6: self = .pushConfig
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .updateUser: return 0
    case .updateTunnel: return 1
    case .updateTunnels: return 2
    case .updateNodes: return 3
    case .appendLog: return 4
    case .pushUpdate: return 5
    case .pushConfig: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PushMessageID: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PushMessageID] = [
    .updateUser,
    .updateTunnel,
    .updateTunnels,
    .updateNodes,
    .appendLog,
    .pushUpdate,
    .pushConfig,
  ]
}

#endif  // swift(>=4.2)

struct Log {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: String = String()

  var data: String = String()

  var category: Int32 = 0

  var time: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LogList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [Log] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ServiceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bypassProxy: Bool = false

  var updateInterval: Int32 = 0

  var remoteManagement: Bool = false

  var remoteKeySet: Bool = false

  var remoteKeyNew: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UpdateStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updateAvailable: Bool = false

  var updateReadyDir: String = String()

  var downloadCurrent: UInt32 = 0

  var downloadTotal: UInt32 = 0

  var note: String = String()

  var updateManagerRunning: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ResponseBase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var message: String = String()

  var data: ResponseBase.OneOf_Data? = nil

  var dataUser: User {
    get {
      if case .dataUser(let v)? = data {return v}
      return User()
    }
    set {data = .dataUser(newValue)}
  }

  var dataTunnel: Tunnel {
    get {
      if case .dataTunnel(let v)? = data {return v}
      return Tunnel()
    }
    set {data = .dataTunnel(newValue)}
  }

  var dataTunnels: TunnelList {
    get {
      if case .dataTunnels(let v)? = data {return v}
      return TunnelList()
    }
    set {data = .dataTunnels(newValue)}
  }

  var dataLog: LogList {
    get {
      if case .dataLog(let v)? = data {return v}
      return LogList()
    }
    set {data = .dataLog(newValue)}
  }

  var dataNodes: NodeList {
    get {
      if case .dataNodes(let v)? = data {return v}
      return NodeList()
    }
    set {data = .dataNodes(newValue)}
  }

  var dataConfig: ServiceConfig {
    get {
      if case .dataConfig(let v)? = data {return v}
      return ServiceConfig()
    }
    set {data = .dataConfig(newValue)}
  }

  var dataUpdate: UpdateStatus {
    get {
      if case .dataUpdate(let v)? = data {return v}
      return UpdateStatus()
    }
    set {data = .dataUpdate(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case dataUser(User)
    case dataTunnel(Tunnel)
    case dataTunnels(TunnelList)
    case dataLog(LogList)
    case dataNodes(NodeList)
    case dataConfig(ServiceConfig)
    case dataUpdate(UpdateStatus)

  #if !swift(>=4.1)
    static func ==(lhs: ResponseBase.OneOf_Data, rhs: ResponseBase.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dataUser, .dataUser): return {
        guard case .dataUser(let l) = lhs, case .dataUser(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataTunnel, .dataTunnel): return {
        guard case .dataTunnel(let l) = lhs, case .dataTunnel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataTunnels, .dataTunnels): return {
        guard case .dataTunnels(let l) = lhs, case .dataTunnels(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataLog, .dataLog): return {
        guard case .dataLog(let l) = lhs, case .dataLog(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataNodes, .dataNodes): return {
        guard case .dataNodes(let l) = lhs, case .dataNodes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataConfig, .dataConfig): return {
        guard case .dataConfig(let l) = lhs, case .dataConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataUpdate, .dataUpdate): return {
        guard case .dataUpdate(let l) = lhs, case .dataUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct RequestBase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: MessageID = .userLogin

  var data: RequestBase.OneOf_Data? = nil

  var dataID: Int32 {
    get {
      if case .dataID(let v)? = data {return v}
      return 0
    }
    set {data = .dataID(newValue)}
  }

  /// For frpc, currently unused in launcher
  var dataString: String {
    get {
      if case .dataString(let v)? = data {return v}
      return String()
    }
    set {data = .dataString(newValue)}
  }

  var dataUserLogin: UserLogin {
    get {
      if case .dataUserLogin(let v)? = data {return v}
      return UserLogin()
    }
    set {data = .dataUserLogin(newValue)}
  }

  var dataUpdateTunnel: UpdateTunnelStatus {
    get {
      if case .dataUpdateTunnel(let v)? = data {return v}
      return UpdateTunnelStatus()
    }
    set {data = .dataUpdateTunnel(newValue)}
  }

  var dataCreateTunnel: CreateTunnel {
    get {
      if case .dataCreateTunnel(let v)? = data {return v}
      return CreateTunnel()
    }
    set {data = .dataCreateTunnel(newValue)}
  }

  var dataConfig: ServiceConfig {
    get {
      if case .dataConfig(let v)? = data {return v}
      return ServiceConfig()
    }
    set {data = .dataConfig(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case dataID(Int32)
    /// For frpc, currently unused in launcher
    case dataString(String)
    case dataUserLogin(UserLogin)
    case dataUpdateTunnel(UpdateTunnelStatus)
    case dataCreateTunnel(CreateTunnel)
    case dataConfig(ServiceConfig)

  #if !swift(>=4.1)
    static func ==(lhs: RequestBase.OneOf_Data, rhs: RequestBase.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dataID, .dataID): return {
        guard case .dataID(let l) = lhs, case .dataID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataString, .dataString): return {
        guard case .dataString(let l) = lhs, case .dataString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataUserLogin, .dataUserLogin): return {
        guard case .dataUserLogin(let l) = lhs, case .dataUserLogin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataUpdateTunnel, .dataUpdateTunnel): return {
        guard case .dataUpdateTunnel(let l) = lhs, case .dataUpdateTunnel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataCreateTunnel, .dataCreateTunnel): return {
        guard case .dataCreateTunnel(let l) = lhs, case .dataCreateTunnel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataConfig, .dataConfig): return {
        guard case .dataConfig(let l) = lhs, case .dataConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct PushMessageBase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: PushMessageID = .updateUser

  var data: PushMessageBase.OneOf_Data? = nil

  var dataUser: User {
    get {
      if case .dataUser(let v)? = data {return v}
      return User()
    }
    set {data = .dataUser(newValue)}
  }

  var dataTunnel: Tunnel {
    get {
      if case .dataTunnel(let v)? = data {return v}
      return Tunnel()
    }
    set {data = .dataTunnel(newValue)}
  }

  var dataTunnels: TunnelList {
    get {
      if case .dataTunnels(let v)? = data {return v}
      return TunnelList()
    }
    set {data = .dataTunnels(newValue)}
  }

  var dataNodes: NodeList {
    get {
      if case .dataNodes(let v)? = data {return v}
      return NodeList()
    }
    set {data = .dataNodes(newValue)}
  }

  var dataLog: LogList {
    get {
      if case .dataLog(let v)? = data {return v}
      return LogList()
    }
    set {data = .dataLog(newValue)}
  }

  var dataUpdate: UpdateStatus {
    get {
      if case .dataUpdate(let v)? = data {return v}
      return UpdateStatus()
    }
    set {data = .dataUpdate(newValue)}
  }

  var dataConfig: ServiceConfig {
    get {
      if case .dataConfig(let v)? = data {return v}
      return ServiceConfig()
    }
    set {data = .dataConfig(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case dataUser(User)
    case dataTunnel(Tunnel)
    case dataTunnels(TunnelList)
    case dataNodes(NodeList)
    case dataLog(LogList)
    case dataUpdate(UpdateStatus)
    case dataConfig(ServiceConfig)

  #if !swift(>=4.1)
    static func ==(lhs: PushMessageBase.OneOf_Data, rhs: PushMessageBase.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dataUser, .dataUser): return {
        guard case .dataUser(let l) = lhs, case .dataUser(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataTunnel, .dataTunnel): return {
        guard case .dataTunnel(let l) = lhs, case .dataTunnel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataTunnels, .dataTunnels): return {
        guard case .dataTunnels(let l) = lhs, case .dataTunnels(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataNodes, .dataNodes): return {
        guard case .dataNodes(let l) = lhs, case .dataNodes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataLog, .dataLog): return {
        guard case .dataLog(let l) = lhs, case .dataLog(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataUpdate, .dataUpdate): return {
        guard case .dataUpdate(let l) = lhs, case .dataUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataConfig, .dataConfig): return {
        guard case .dataConfig(let l) = lhs, case .dataConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension MessageID: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_LOGIN"),
    1: .same(proto: "USER_LOGOUT"),
    2: .same(proto: "USER_INFO"),
    3: .same(proto: "TUNNEL_LIST"),
    4: .same(proto: "TUNNEL_RELOAD"),
    5: .same(proto: "TUNNEL_UPDATE"),
    6: .same(proto: "LOG_GET"),
    7: .same(proto: "LOG_CLEAR"),
    8: .same(proto: "TUNNEL_DELETE"),
    9: .same(proto: "TUNNEL_CREATE"),
    10: .same(proto: "NODE_LIST"),
    11: .same(proto: "NODE_RELOAD"),
    12: .same(proto: "CONTROL_EXIT"),
    13: .same(proto: "CONTROL_CONFIG_GET"),
    14: .same(proto: "CONTROL_CONFIG_SET"),
    15: .same(proto: "CONTROL_CHECK_UPDATE"),
    16: .same(proto: "CONTROL_GET_UPDATE"),
  ]
}

extension PushMessageID: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATE_USER"),
    1: .same(proto: "UPDATE_TUNNEL"),
    2: .same(proto: "UPDATE_TUNNELS"),
    3: .same(proto: "UPDATE_NODES"),
    4: .same(proto: "APPEND_LOG"),
    5: .same(proto: "PUSH_UPDATE"),
    6: .same(proto: "PUSH_CONFIG"),
  ]
}

extension Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Log"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "data"),
    3: .same(proto: "category"),
    4: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.category) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    if self.category != 0 {
      try visitor.visitSingularInt32Field(value: self.category, fieldNumber: 3)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt32Field(value: self.time, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Log, rhs: Log) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.data != rhs.data {return false}
    if lhs.category != rhs.category {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LogList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LogList, rhs: LogList) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServiceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServiceConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bypass_proxy"),
    2: .standard(proto: "update_interval"),
    3: .standard(proto: "remote_management"),
    4: .standard(proto: "remote_key_set"),
    5: .standard(proto: "remote_key_new"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.bypassProxy) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.updateInterval) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.remoteManagement) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.remoteKeySet) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.remoteKeyNew) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bypassProxy != false {
      try visitor.visitSingularBoolField(value: self.bypassProxy, fieldNumber: 1)
    }
    if self.updateInterval != 0 {
      try visitor.visitSingularInt32Field(value: self.updateInterval, fieldNumber: 2)
    }
    if self.remoteManagement != false {
      try visitor.visitSingularBoolField(value: self.remoteManagement, fieldNumber: 3)
    }
    if self.remoteKeySet != false {
      try visitor.visitSingularBoolField(value: self.remoteKeySet, fieldNumber: 4)
    }
    if !self.remoteKeyNew.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteKeyNew, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ServiceConfig, rhs: ServiceConfig) -> Bool {
    if lhs.bypassProxy != rhs.bypassProxy {return false}
    if lhs.updateInterval != rhs.updateInterval {return false}
    if lhs.remoteManagement != rhs.remoteManagement {return false}
    if lhs.remoteKeySet != rhs.remoteKeySet {return false}
    if lhs.remoteKeyNew != rhs.remoteKeyNew {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_available"),
    2: .standard(proto: "update_ready_dir"),
    3: .standard(proto: "download_current"),
    4: .standard(proto: "download_total"),
    5: .same(proto: "note"),
    6: .standard(proto: "update_manager_running"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.updateAvailable) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.updateReadyDir) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.downloadCurrent) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.downloadTotal) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.note) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.updateManagerRunning) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.updateAvailable != false {
      try visitor.visitSingularBoolField(value: self.updateAvailable, fieldNumber: 1)
    }
    if !self.updateReadyDir.isEmpty {
      try visitor.visitSingularStringField(value: self.updateReadyDir, fieldNumber: 2)
    }
    if self.downloadCurrent != 0 {
      try visitor.visitSingularUInt32Field(value: self.downloadCurrent, fieldNumber: 3)
    }
    if self.downloadTotal != 0 {
      try visitor.visitSingularUInt32Field(value: self.downloadTotal, fieldNumber: 4)
    }
    if !self.note.isEmpty {
      try visitor.visitSingularStringField(value: self.note, fieldNumber: 5)
    }
    if self.updateManagerRunning != false {
      try visitor.visitSingularBoolField(value: self.updateManagerRunning, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateStatus, rhs: UpdateStatus) -> Bool {
    if lhs.updateAvailable != rhs.updateAvailable {return false}
    if lhs.updateReadyDir != rhs.updateReadyDir {return false}
    if lhs.downloadCurrent != rhs.downloadCurrent {return false}
    if lhs.downloadTotal != rhs.downloadTotal {return false}
    if lhs.note != rhs.note {return false}
    if lhs.updateManagerRunning != rhs.updateManagerRunning {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResponseBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResponseBase"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "message"),
    3: .standard(proto: "data_user"),
    4: .standard(proto: "data_tunnel"),
    5: .standard(proto: "data_tunnels"),
    7: .standard(proto: "data_log"),
    6: .standard(proto: "data_nodes"),
    8: .standard(proto: "data_config"),
    9: .standard(proto: "data_update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try {
        var v: User?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataUser(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataUser(v)
        }
      }()
      case 4: try {
        var v: Tunnel?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataTunnel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataTunnel(v)
        }
      }()
      case 5: try {
        var v: TunnelList?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataTunnels(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataTunnels(v)
        }
      }()
      case 6: try {
        var v: NodeList?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataNodes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataNodes(v)
        }
      }()
      case 7: try {
        var v: LogList?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataLog(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataLog(v)
        }
      }()
      case 8: try {
        var v: ServiceConfig?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataConfig(v)
        }
      }()
      case 9: try {
        var v: UpdateStatus?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataUpdate(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.data {
    case .dataUser?: try {
      guard case .dataUser(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .dataTunnel?: try {
      guard case .dataTunnel(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .dataTunnels?: try {
      guard case .dataTunnels(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .dataNodes?: try {
      guard case .dataNodes(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .dataLog?: try {
      guard case .dataLog(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .dataConfig?: try {
      guard case .dataConfig(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .dataUpdate?: try {
      guard case .dataUpdate(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResponseBase, rhs: ResponseBase) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RequestBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RequestBase"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "data_id"),
    7: .standard(proto: "data_string"),
    3: .standard(proto: "data_user_login"),
    4: .standard(proto: "data_update_tunnel"),
    5: .standard(proto: "data_create_tunnel"),
    6: .standard(proto: "data_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .dataID(v)
        }
      }()
      case 3: try {
        var v: UserLogin?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataUserLogin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataUserLogin(v)
        }
      }()
      case 4: try {
        var v: UpdateTunnelStatus?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataUpdateTunnel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataUpdateTunnel(v)
        }
      }()
      case 5: try {
        var v: CreateTunnel?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataCreateTunnel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataCreateTunnel(v)
        }
      }()
      case 6: try {
        var v: ServiceConfig?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataConfig(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .dataString(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .userLogin {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.data {
    case .dataID?: try {
      guard case .dataID(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case .dataUserLogin?: try {
      guard case .dataUserLogin(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .dataUpdateTunnel?: try {
      guard case .dataUpdateTunnel(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .dataCreateTunnel?: try {
      guard case .dataCreateTunnel(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .dataConfig?: try {
      guard case .dataConfig(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .dataString?: try {
      guard case .dataString(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RequestBase, rhs: RequestBase) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PushMessageBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PushMessageBase"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    3: .standard(proto: "data_user"),
    4: .standard(proto: "data_tunnel"),
    5: .standard(proto: "data_tunnels"),
    6: .standard(proto: "data_nodes"),
    7: .standard(proto: "data_log"),
    8: .standard(proto: "data_update"),
    9: .standard(proto: "data_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try {
        var v: User?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataUser(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataUser(v)
        }
      }()
      case 4: try {
        var v: Tunnel?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataTunnel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataTunnel(v)
        }
      }()
      case 5: try {
        var v: TunnelList?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataTunnels(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataTunnels(v)
        }
      }()
      case 6: try {
        var v: NodeList?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataNodes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataNodes(v)
        }
      }()
      case 7: try {
        var v: LogList?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataLog(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataLog(v)
        }
      }()
      case 8: try {
        var v: UpdateStatus?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataUpdate(v)
        }
      }()
      case 9: try {
        var v: ServiceConfig?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataConfig(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .updateUser {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.data {
    case .dataUser?: try {
      guard case .dataUser(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .dataTunnel?: try {
      guard case .dataTunnel(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .dataTunnels?: try {
      guard case .dataTunnels(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .dataNodes?: try {
      guard case .dataNodes(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .dataLog?: try {
      guard case .dataLog(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .dataUpdate?: try {
      guard case .dataUpdate(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .dataConfig?: try {
      guard case .dataConfig(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PushMessageBase, rhs: PushMessageBase) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
